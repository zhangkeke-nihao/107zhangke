本周所学知识

（1）收获最大的内容：
	
	组件：独立的可重复使用的部分，可以单独考虑每个组件的渲染。就相当于HTML页面上面的单个元素
		如何把组件渲染到页面：   <组件名 />  自定义元素，代表一个组件
		  可以通过这个组件由父类向组件传数据，用 变量={要传输的数据/方法}，然后在组件里面用 const {变量} = this.props接收从父类传过来的数据,
		  this.props就相当于一个管道，一个从父类向组件传输数据的管道，所有的数据（变量，方法）都要通过这个管道（this.props）来传输。
		子类接收到父类传过来的方法，如何向父类的这个方法传递参数： 组件this.props.函数名(参数)    父类 函数名（参数）{}
		子类不能修改props


	state:表示状态，是组件私有的    不要直接修改state，用setState()修改state



（2）第一天：
	Flexbox ：弹性盒模型，灵活的盒子容器
	可以简便、完整、响应式地实现各种页面布局，既可以应用于容器中，也可以应用于行内元素
	可以收缩和扩展flex容器内的元素，以最大限度的填充可用空间

（3）第二天：
	1、
	  let：代码块内有效，会绑定这个区域，不受外部影响
	  var  会提升变量，不推荐使用
	  因为js解析时会先编译再执行，编译阶段会先声明，会把变量提升到作用域的最顶部并初始化为undefined，
	
	2、this对象：this就是指向调用函数的对象。类的方法内部如果含有this，它默认指向类的实例。
	  如果将一个对象的方法赋值给了一个全局变量，然后利用这个全局变量来调用这个方法，那么此时this指向的是window对象
	  如果object对象调用的函数里面有一个闭包，闭包如果也想访问到object对象里面的其他方法或属性，可以利用一个变量把this存起来，然后this就缓存到了变量中，
	  再利用这个变量访问object对象的其他属性或方法。
	  
	3、bind（）: 绑定函数，传入的参数作为这个绑定函数的this对象，就是用来重定义this这个对象的。
	  apply（改变this指向的参数，[参数]）、call（改变this指向的参数，参数，参数...）会立即执行，而bind（改变this指向的参数，参数，参数...）是返回了一个新的函数，不是立即执行
	
（4）第三天：	  
	类：把对象中具有的共同特征抽象出来，可复用性高。
	    子类继承父类，其中一个改变父类的方法，不会对其他子类继承父类的这个方法造成影响
	